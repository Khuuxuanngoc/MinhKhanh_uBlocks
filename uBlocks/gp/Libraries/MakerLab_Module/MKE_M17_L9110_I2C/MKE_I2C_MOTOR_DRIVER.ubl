module MKE_I2C_MOTOR_DRIVER
author MinhKhanh210
version 1 0 
depends 'sensorPrims'
description ''
variables _pulseMax _pusleMin _MAKERLABVN_I2C_DRIVER_MAX_NUMBER_DRIVER_SUPPORT _MAKERLABVN_I2C_DRIVER_SLAVE_ADDRESS_MIN _MAKERLABVN_I2C_DRIVER_SLAVE_ADDRESS_MAX _MAKERLABVN_I2C_DRIVER_PULSE_TIME_MAX _MAKERLABVN_I2C_DRIVER_PULSE_TIME_MIN _MAX_I2C_MOTOR_DC_SIZE _MAX_I2C_MOTOR_RC_SIZE _DELAY_I2C_SEND _MAKERLABVN_I2C_DRIVER_INDEX_MA _MAKERLABVN_I2C_DRIVER_INDEX_MB _MAKERLABVN_I2C_DRIVER_INDEX_S1 _MAKERLABVN_I2C_DRIVER_INDEX_S2 _I2C_MOTOR_DRIVER_PULSE_DISABLE 

  spec ' ' 'Set max pulse (microsecond)' 'Set max pulse value (microsecond) _ for Servo _ in address _' 'auto str auto' 2350 'S1' 0
  spec ' ' 'Set min pulse (microsecond)' 'Set min pulse value (microsecond) _ for Servo _ in address _' 'auto str auto' 460 'S1' 0
  spec ' ' 'Set this driver''s address to' 'Set this driver''s address to _' 'auto' 0
  spec ' ' '_MKE-M10 Configuration' '_MKE-M10 Configuration'
  spec 'r' '_addrConvert' '_addrConvert _' 'num' 0
  spec 'r' '_directConvert' '_directConvert _' 'str' 'forward'
  spec 'r' '_motorConvert' '_motorConvert _' 'str' 'A'
  spec 'r' '_powerConvert' '_powerConvert _' 'num' 50
  spec 'r' '_pulseDegConvert' '_pulseDegConvert _' 'auto' 90
  spec ' ' 'freeMotorRC I2C | Address' 'freeMotorRC I2C | Address _ Servo _' 'auto str' 0 'S1'
  spec ' ' 'runMotor' 'runMotorDC I2C | Address _ Motor _ move _ at power (%) _' 'num str auto auto' 0 'A' 'forward' 50
  spec ' ' 'runMotorRC I2C | Address' 'runMotorRC I2C | Address _ Servo _ angle as (0° ~ 180°) _' 'num str num' 0 'S1' 90
  spec ' ' 'stopMotorDC I2C | Address' 'stopMotorDC I2C | Address _ Motor _' 'auto str' 0 'A'

to 'Set max pulse (microsecond)' _pulseMaxInput _motorWhich _addressWhich {
  _pulseMax = _pulseMaxInput
}

to 'Set min pulse (microsecond)' _pusleMinInput _motorWhich _addressWhich {
  _pusleMin = _pusleMinInput
}

to 'Set this driver' s address to' _address {
}

to '_MKE-M10 Configuration' {
  _MAKERLABVN_I2C_DRIVER_MAX_NUMBER_DRIVER_SUPPORT = 5
  _MAKERLABVN_I2C_DRIVER_SLAVE_ADDRESS_MIN = 64
  _MAKERLABVN_I2C_DRIVER_SLAVE_ADDRESS_MAX = (_MAKERLABVN_I2C_DRIVER_SLAVE_ADDRESS_MIN + _MAKERLABVN_I2C_DRIVER_MAX_NUMBER_DRIVER_SUPPORT)
  _MAKERLABVN_I2C_DRIVER_PULSE_TIME_MIN = 460
  _MAKERLABVN_I2C_DRIVER_PULSE_TIME_MAX = 2350
  _MAX_I2C_MOTOR_DC_SIZE = 2
  _MAX_I2C_MOTOR_DC_SIZE = 2
  _DELAY_I2C_SEND = 15
  _MAKERLABVN_I2C_DRIVER_INDEX_MA = 0
  _MAKERLABVN_I2C_DRIVER_INDEX_MB = 1
  _MAKERLABVN_I2C_DRIVER_INDEX_S1 = 0
  _MAKERLABVN_I2C_DRIVER_INDEX_S2 = 1
  _I2C_MOTOR_DRIVER_PULSE_DISABLE = 3000
}

to '_addrConvert' _addrIn {
  for i 5 {
    local 'i-1' (i - 1)
    if (_addrIn == i-1) {
      sayIt i-1 (64 + i-1)
      return (64 + i-1)
    }
  }
}

to '_directConvert' _directIn {
  return (ifExpression (_directIn == ('[data:toString]' 'forward')) 1 (ifExpression (_directIn == ('[data:toString]' 'backward')) 0 (booleanConstant false)))
}

to '_motorConvert' _motorIn {
  return (ifExpression (_motorIn == ('[data:toString]' 'A')) 0 (ifExpression (_motorIn == ('[data:toString]' 'B')) 1 (ifExpression (_motorIn == ('[data:toString]' 'S1')) 1 (ifExpression (_motorIn == ('[data:toString]' 'S2')) 2 (booleanConstant false)))))
}

to '_powerConvert' _powerIn {
  return ('[misc:rescale]' _powerIn 0 100 0 255)
}

to '_pulseDegConvert' _DegIn {
  return ('[misc:rescale]' _DegIn 0 180 _pusleMin _pulseMax)
}

to 'freeMotorRC I2C | Address' _address _motorWhich {
  local 'var' ('[data:newByteArray]' 6)
  atPut 1 var ('_addrConvert' _address)
  atPut 2 var 0
  atPut 3 var ('_motorConvert' _motorWhich)
  atPut 4 var ((3000 >> 8) & (hexToInt 'FF'))
  atPut 5 var (3000 & (hexToInt 'FF'))
  local 'checkSum' 0
  for i ((size var) - 1) {
    checkSum = (checkSum + (at i var))
  }
  atPut 6 var (checkSum & (hexToInt 'FF'))
  sayIt ('[data:asByteArray]' var) (at 1 var) (at 2 var) (at 3 var) (at 4 var) (at 5 var) (at 6 var)
  '[sensors:i2cWrite]' ('_addrConvert' _addr) var
}

to getErrorName errorCode {
  if (errorCode == I2C_MOTOR_DRIVER_CODE_FAIL) {return 'FAIL'}
  if (errorCode == I2C_MOTOR_DRIVER_CODE_SUCCESS) {return 'SUCCESS'}
  if (errorCode == I2C_MOTOR_DRIVER_CODE_NOT_CONNECT) {return 'NOT_CONNECT'}
  if (errorCode == I2C_MOTOR_DRIVER_CODE_MANY_CONNECT) {return 'MANY_CONNECT'}
  if (errorCode == I2C_MOTOR_DRIVER_CODE_INVALID_ADDRESS) {return 'INVALID_ADDRESS'}
  if (errorCode == END_I2C_MOTOR_DRIVER_CODE) {return 'END_CODE'}
  return 'UNKNOWN_ERROR'
}

to getModeName modeId {
  if (modeId == RC_ID) {return 'RC_ID'}
  if (modeId == DC_ID) {return 'DC_ID'}
  if (modeId == SADDR_ID) {return 'SADDR_ID'}
  if (modeId == END_MODE_ID) {return 'END_MODE_ID'}
  return 'UNKNOWN_MODE'
}

to runMotor _addr _motorWhich _direction _powerPercent {
  local 'var' ('[data:newByteArray]' 6)
  atPut 1 var ('_addrConvert' _addr)
  atPut 2 var 1
  atPut 3 var ('_motorConvert' _motorWhich)
  atPut 4 var ('_powerConvert' _powerPercent)
  atPut 5 var ('_directConvert' _direction)
  local 'checkSum' 0
  for i ((size var) - 1) {
    checkSum = (checkSum + (at i var))
  }
  atPut 6 var (checkSum & (hexToInt 'FF'))
  sayIt ('[data:asByteArray]' var) (at 1 var) (at 2 var) (at 3 var) (at 4 var) (at 5 var) (at 6 var)
  '[sensors:i2cWrite]' ('_addrConvert' _addr) var
}

to 'runMotorRC I2C | Address' _address _motorWhich _angle {
  local 'var' ('[data:newByteArray]' 6)
  atPut 1 var ('_addrConvert' _address)
  atPut 2 var 0
  atPut 3 var ('_motorConvert' _motorWhich)
  atPut 4 var ((('_pulseDegConvert' _angle) >> 8) & (hexToInt 'FF'))
  atPut 5 var (('_pulseDegConvert' _angle) & (hexToInt 'FF'))
  local 'checkSum' 0
  for i ((size var) - 1) {
    checkSum = (checkSum + (at i var))
  }
  atPut 6 var (checkSum & (hexToInt 'FF'))
  sayIt ('[data:asByteArray]' var) (at 1 var) (at 2 var) (at 3 var) (at 4 var) (at 5 var) (at 6 var)
  '[sensors:i2cWrite]' ('_addrConvert' _addr) var
}

to 'stopMotorDC I2C | Address' _addresss _motorWhich {
  runMotor _addresss _motorWhich 'forward' 0
}

