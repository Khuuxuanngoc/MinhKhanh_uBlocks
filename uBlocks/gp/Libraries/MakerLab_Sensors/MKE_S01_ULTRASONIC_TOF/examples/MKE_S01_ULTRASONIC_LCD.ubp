module main
author unknown
version 1 0 
description ''

script 54 54 {
whenStarted
LCD1602_write 'Test S01' 1
forever {
  LCD1602_write ('[data:join]' 'Distance: ' ('distance (cm)' 12 13) ' cm ') 2
  sayIt ('[data:join]' 'Distance: ' ('distance (cm)' 12 13) ' (cm) ')
  waitMillis 200
}
}


module MKE_M07_M08_I2C_LCD
author MinhKhanh210
version 1 2 
depends sensorPrims 
description ''
variables _LCD1602_ADDR _LCD1602_LINE1 _LCD1602_LINE2 _LCD1602_LOCK_MSECS _LCD2004_LINE3 _LCD2004_LINE4 

  spec ' ' 'LCD1602_write' 'LCD I2C | Print _ at Row _' 'str num' 'MakerEDU' 1
  spec ' ' 'LCD1602_write_field' 'LCD I2C | Print _ at Row _ and Columm _ to Columm _' 'str num num num' 'labVN' 1 6 10
  spec ' ' 'LCD_write_at_r_and_c' 'LCD I2C | Print _ at Columm _ and Row _' 'auto num num' 'MakerlabVN' 1 1
  space
  spec ' ' 'LCD1602_clear' 'LCD I2C | Clear all'
  space
  spec 'r' 'LCD1602_isConnected' 'is LCD connected?'
  spec ' ' 're-initialize' 're-initialize'
  space
  spec 'r' '_LCD1602 init' '_LCD1602 init'
  spec ' ' '_LCD1602 send' '_LCD1602 send byte _ mode _' 'num num' 10 1
  spec ' ' '_LCD1602 toggle enable' '_LCD1602 toggle enable _' 'num' 10
  spec ' ' 'LCD1602_write_buffer' '_write_buffer _' 'auto' 0

to LCD1602_clear {
  if (not ('_LCD1602 init')) {return}
  waitUntil (((millisOp) - _LCD1602_LOCK_MSECS) > 500)
  _LCD1602_LOCK_MSECS = (millisOp)
  _LCD1602_LINE1 = ('[data:newByteArray]' 20 32)
  _LCD1602_LINE2 = ('[data:newByteArray]' 20 32)
  _LCD2004_LINE3 = ('[data:newByteArray]' 20 32)
  _LCD2004_LINE4 = ('[data:newByteArray]' 20 32)
  '_LCD1602 send' 1 0
  _LCD1602_LOCK_MSECS = 0
}

to LCD1602_isConnected {
  return ('_LCD1602 init')
}

to LCD1602_write string line {
  LCD1602_write_field string line 1 20
}

to LCD1602_write_buffer line {
  local 'bytes' 0
  if (line == 1) {
    '_LCD1602 send' (hexToInt '80') 0
    bytes = _LCD1602_LINE1
  } (line == 2) {
    '_LCD1602 send' (hexToInt 'C0') 0
    bytes = _LCD1602_LINE2
  } (line == 3) {
    '_LCD1602 send' (hexToInt '94') 0
    bytes = _LCD2004_LINE3
  } else {
    if (line == 4) {
      '_LCD1602 send' (hexToInt 'D4') 0
      bytes = _LCD2004_LINE4
    }
  }
  for b bytes {
    '_LCD1602 send' b 1
  }
}

to LCD1602_write_field string line start end {
  if (not ('_LCD1602 init')) {return}
  if (start < 1) {
    sayIt 'first columm must start with 1'
    return
  }
  if (end > 20) {
    end = 20
  }
  string = ('[data:join]' '' string)
  if (line == 1) {
    bytes = _LCD1602_LINE1
  } (line == 2) {
    bytes = _LCD1602_LINE2
  } (line == 3) {
    bytes = _LCD2004_LINE3
  } else {
    if (line == 4) {bytes = _LCD2004_LINE4}
  }
  waitUntil (((millisOp) - _LCD1602_LOCK_MSECS) > 500)
  _LCD1602_LOCK_MSECS = (millisOp)
  local 'count' ((end - start) + 1)
  for i count {
    local 'char' 32
    if (i <= (size string)) {
      char = ('[data:unicodeAt]' i string)
      if (char > 127) {
        char = 32
      }
      atPut ((start - 1) + i) bytes char
    } else {
      atPut ((start - 1) + i) bytes char
    }
  }
  LCD1602_write_buffer line
  _LCD1602_LOCK_MSECS = 0
}

to LCD_write_at_r_and_c string col row {
  LCD1602_write_field string row col ((size string) + col)
}

to '_LCD1602 init' {
  comment 'Return true if already initialized'
  if (_LCD1602_ADDR != 0) {
    return true
  }
  comment 'Use slow I2C speed'
  '[sensors:i2cSetClockSpeed]' 100000
  comment 'Try two common I2C addresses and
use the one that gets a response'
  _LCD1602_ADDR = (hexToInt '27')
  if ((i2cGet _LCD1602_ADDR 0) < 0) {
    _LCD1602_ADDR = (hexToInt '3F')
  }
  if ((i2cGet _LCD1602_ADDR 0) < 0) {
    _LCD1602_ADDR = 0
    comment 'LCD panel not found'
    return false
  }
  _LCD1602_LINE1 = ('[data:newByteArray]' 20 32)
  _LCD1602_LINE2 = ('[data:newByteArray]' 20 32)
  _LCD2004_LINE3 = ('[data:newByteArray]' 20 32)
  _LCD2004_LINE4 = ('[data:newByteArray]' 20 32)
  comment 'Initialize display'
  '_LCD1602 send' (hexToInt '33') 0
  '_LCD1602 send' (hexToInt '32') 0
  '_LCD1602 send' (hexToInt '06') 0
  '_LCD1602 send' (hexToInt '0C') 0
  '_LCD1602 send' (hexToInt '28') 0
  '_LCD1602 send' (hexToInt '01') 0
  '[sensors:i2cSetClockSpeed]' 400000
  waitMillis 250
  return true
}

to '_LCD1602 send' bits mode {
  comment 'Use slow I2C speed'
  '[sensors:i2cSetClockSpeed]' 100000
  local '_LCD1602 BACKLIGHT' (hexToInt '8')
  local 'high bits' ((mode | (bits & (hexToInt 'F0'))) | (v '_LCD1602 BACKLIGHT'))
  local 'low bits' ((mode | ((bits << 4) & (hexToInt 'F0'))) | (v '_LCD1602 BACKLIGHT'))
  '[sensors:i2cWrite]' _LCD1602_ADDR (v 'high bits')
  '_LCD1602 toggle enable' (v 'high bits')
  '[sensors:i2cWrite]' _LCD1602_ADDR (v 'low bits')
  '_LCD1602 toggle enable' (v 'low bits')
  comment 'Revert to fast I2C speed'
  '[sensors:i2cSetClockSpeed]' 400000
  waitMillis 1
}

to '_LCD1602 toggle enable' bits {
  local '_LCD1602 ENABLE' 4
  waitMicros 5
  '[sensors:i2cWrite]' _LCD1602_ADDR (bits | (v '_LCD1602 ENABLE'))
  waitMicros 5
  '[sensors:i2cWrite]' _LCD1602_ADDR (bits & ('~' (v '_LCD1602 ENABLE')))
  waitMicros 5
}

to 're-initialize' {
  _LCD1602_ADDR = 0
}


module S01_Ultrasonic Input
author 'Gia An'
version 1 0 
tags sensor s01_ultrasonic distance 
description 'Support for the S01_Ultrasonic distance sensor.'
variables _sr04_last 

  spec 'r' 'distance (cm)' 'S01 Ultrasonic | Read distance (cm) from trigger pin _ echo  pin _' 'num num' 12 13

to 'distance (cm)' trig ech {
  comment 'Contributed by Joan Guillén and Josep Ferràndiz'
  digitalWriteOp trig false
  waitMicros 2
  digitalWriteOp trig true
  waitMicros 50
  digitalWriteOp trig false
  local 'start' (microsOp)
  waitUntil (or (not (digitalReadOp ech)) (((microsOp) - start) > 23320))
  waitUntil (or (digitalReadOp ech) (((microsOp) - start) > 23320))
  if (((microsOp) - start) > 23320) {
    comment 'Distance sensor not ready; return the last distance reading'
    return _sr04_last
  }
  comment 'Pulse sent. Measure time until echo is detected.'
  start = (microsOp)
  waitUntil (or (not (digitalReadOp ech)) (((microsOp) - start) > 23320))
  _sr04_last = ((10 * ((microsOp) - start)) / 583)
  comment 'Leave some time for reverberations to die away.'
  waitMillis 10
  return _sr04_last
}


module 'Sensor Primitives' Input
author MicroBlocks
version 1 1 
tags tilt acceleration light sensor capacitive button 
description 'Provides blocks to read tilt in the three axes, acceleration, temperature and light level. Many boards come with this particular set of sensors, such as the micro:bit, the Circuit Playground Express, the Calliope or the Citilab ED1.'

  spec 'r' '[sensors:tiltX]' 'tilt x'
  spec 'r' '[sensors:tiltY]' 'tilt y'
  spec 'r' '[sensors:tiltZ]' 'tilt z'
  spec 'r' '[display:lightLevel]' 'light level'
  spec 'r' '[sensors:temperature]' 'temperature (°C)'
  space
  spec 'r' '[sensors:touchRead]' 'capacitive sensor _' 'num' 1
  space
  spec ' ' '[sensors:i2cSetClockSpeed]' 'set i2c clock speed _' 'num' 400000
  spec ' ' '[sensors:i2cSetPins]' 'set i2c pins SDA _ SCL _' 'num num' 4 5
